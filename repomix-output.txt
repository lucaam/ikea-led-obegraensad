This file is a merged representation of the entire codebase, combining all repository files into a single document.
Generated by Repomix on: 2025-01-10T20:16:21.190Z

================================================================
File Summary
================================================================

Purpose:
--------
This file contains a packed representation of the entire repository's contents.
It is designed to be easily consumable by AI systems for analysis, code review,
or other automated processes.

File Format:
------------
The content is organized as follows:
1. This summary section
2. Repository information
3. Repository structure
4. Multiple file entries, each consisting of:
  a. A separator line (================)
  b. The file path (File: path/to/file)
  c. Another separator line
  d. The full contents of the file
  e. A blank line

Usage Guidelines:
-----------------
- This file should be treated as read-only. Any changes should be made to the
  original repository files, not this packed version.
- When processing this file, use the file path to distinguish
  between different files in the repository.
- Be aware that this file may contain sensitive information. Handle it with
  the same level of security as you would the original repository.

Notes:
------
- Some files may have been excluded based on .gitignore rules and Repomix's
  configuration.
- Binary files are not included in this packed representation. Please refer to
  the Repository Structure section for a complete list of file paths, including
  binary files.

Additional Info:
----------------

For more information about Repomix, visit: https://github.com/yamadashy/repomix

================================================================
Repository Structure
================================================================
frontend/
  src/
    components/
      button.tsx
      creator-sidebar.tsx
      layout.tsx
      led-matrix.tsx
      screen-info.tsx
      sidebar.tsx
      tooltip.tsx
    app.tsx
    creator.tsx
    helpers.ts
    index.css
    index.tsx
    store.tsx
    types.ts
  .env
  compress.mjs
  index.html
  package.json
  postcss.config.js
  tailwind.config.js
  tsconfig.json
  vite.config.mts

================================================================
Repository Files
================================================================

================
File: frontend/src/components/button.tsx
================
import { Component, JSX } from "solid-js";

export const Button: Component<
  JSX.ButtonHTMLAttributes<HTMLButtonElement> & { widthAuto?: boolean }
> = (props) => {
  return (
    <button
      {...props}
      class={`${props.widthAuto ? "w-auto" : "w-full"} bg-blue-600 text-white border-0 px-4 py-3 uppercase text-sm leading-6 tracking-wider cursor-pointer font-bold hover:opacity-80 active:translate-y-[-1px] transition-all rounded disabled:opacity-40 hover:disabled:bg-blue-600 ${
        props.class || ""
      }`}
    >
      {props.children}
    </button>
  );
};

export default Button;

================
File: frontend/src/components/creator-sidebar.tsx
================
import { Component, JSX, Show } from "solid-js";
import { Button } from "./button";
import { Tooltip } from "./tooltip";

interface CreatorSidebarProps {
  hasScreens: boolean;
  isPlaying: boolean;
  onAddScreen: () => void;
  onExportData: () => void;
  onUploadData: () => void;
  onTogglePlay: () => void;
}

export const CreatorSidebar: Component<CreatorSidebarProps> = (props) => {
  return (
    <aside class="bg-white p-6 flex flex-col h-full">
      <div class="space-y-6">
        <div class="space-y-3">
          <h3 class="text-sm font-semibold text-gray-700 uppercase tracking-wide">
            Controls
          </h3>
          <div class="flex gap-4 items-center">
            <Show
              when={!props.isPlaying}
              fallback={
                <Tooltip text="Stop animation">
                  <Button
                    disabled={!props.hasScreens}
                    onClick={props.onTogglePlay}
                    class="hover:bg-red-600 transition-colors"
                  >
                    <i class="fa-solid fa-stop" />
                  </Button>
                </Tooltip>
              }
            >
              <Tooltip text="Add new frame">
                <Button
                  onClick={props.onAddScreen}
                  class="hover:bg-green-600 transition-colors"
                >
                  <i class="fa-solid fa-plus" />
                </Button>
              </Tooltip>

              <Tooltip text="Export animation">
                <Button
                  disabled={!props.hasScreens}
                  onClick={props.onExportData}
                  class="hover:bg-blue-700 transition-colors"
                >
                  <i class="fa-solid fa-download" />
                </Button>
              </Tooltip>

              <Tooltip text="Upload to device">
                <Button
                  disabled={!props.hasScreens}
                  onClick={props.onUploadData}
                  class="hover:bg-blue-700 transition-colors"
                >
                  <i class="fa-solid fa-upload" />
                </Button>
              </Tooltip>

              <Tooltip text="Play animation">
                <Button
                  disabled={!props.hasScreens}
                  onClick={props.onTogglePlay}
                  class="hover:bg-green-600 transition-colors"
                >
                  <i class="fa-solid fa-play" />
                </Button>
              </Tooltip>
            </Show>
          </div>
        </div>
      </div>

      <div class="mt-auto pt-6 border-t border-gray-200">
        <Tooltip text="Return to main editor">
          <a
            href="#/"
            class="inline-flex items-center text-gray-700 hover:text-gray-900 font-medium"
          >
            <i class="fa-solid fa-arrow-left mr-2" />
            Back
          </a>
        </Tooltip>
      </div>
    </aside>
  );
};

export default CreatorSidebar;

================
File: frontend/src/components/layout.tsx
================
import { Component, Show } from 'solid-js';
import { Sidebar } from './sidebar';

export const Layout: Component<{
  content: any;
  sidebarContent?: any;
  store?: any;
  onRotate?: (turnRight: boolean) => void;
  onLoadImage?: () => void;
  onClear?: () => void;
  onPersist?: () => void;
  onLoad?: () => void;
  onPluginChange?: (pluginId: number) => void;
  onBrightnessChange?: (value: number) => void;
  onPersistPlugin?: () => void;
  ref?: any;
}> = (props) => {
  return (
    <div
      class={`h-full ${
        props.store?.connectionState() === 1 ? 'grid grid-cols-[320px_1fr]' : ''
      }`}
    >
      <Show when={props.store?.connectionState() === 1}>
        <Show when={!props.sidebarContent} fallback={props.sidebarContent}>
          <Sidebar
            store={props.store!}
            onRotate={props.onRotate!}
            onLoadImage={props.onLoadImage!}
            onClear={props.onClear!}
            onPersist={props.onPersist!}
            onLoad={props.onLoad!}
            onPluginChange={props.onPluginChange!}
            onBrightnessChange={props.onBrightnessChange!}
            onPersistPlugin={props.onPersistPlugin!}
          />
        </Show>
      </Show>
      <main class="h-full overflow-auto" ref={props.ref}>
        {props.content}
      </main>
    </div>
  );
};

export default Layout;

================
File: frontend/src/components/led-matrix.tsx
================
import { Component, createEffect, onCleanup, onMount } from "solid-js";
import { createVisibilityObserver } from "@solid-primitives/intersection-observer";
import { Accessor } from "solid-js";

interface Props {
  disabled?: boolean;
  onSetLed?: (data: { index: number; status: number }) => void;
  onSetMatrix?: (data: number[]) => void;
  data: Accessor<number[]>;
  indexData: Accessor<number[]>;
}

export const LedMatrix: Component<Props> = (props) => {
  let canvasRef: HTMLCanvasElement | undefined;
  let containerRef: HTMLDivElement | undefined;
  let isDrawing = false;
  let currentDrawValue = 255;

  const MATRIX_SIZE = 16;
  const LED_COLORS = {
    OFF: "#333333",
    BACKGROUND: "#111111",
  };

  const useVisibilityObserver = createVisibilityObserver({ threshold: 0.9 });
  const visible = useVisibilityObserver(() => containerRef);

  const getLedColor = (brightness: number) => {
    if (brightness <= 0) return LED_COLORS.OFF;

    const intensity = Math.min(255, Math.max(0, brightness));
    return `rgb(${intensity}, ${intensity}, ${intensity})`;
  };

  const drawMatrix = (data: number[], indexData: number[]) => {
    if (!canvasRef) return;

    const ctx = canvasRef.getContext("2d")!;
    const canvas = canvasRef;
    const cellSize = canvas.width / MATRIX_SIZE;
    const padding = 4;

    ctx.fillStyle = LED_COLORS.BACKGROUND;
    ctx.fillRect(0, 0, canvas.width, canvas.height);

    for (let y = 0; y < MATRIX_SIZE; y++) {
      for (let x = 0; x < MATRIX_SIZE; x++) {
        const index = y * MATRIX_SIZE + x;
        const mappedIndex = indexData[index];
        const brightness = data[mappedIndex];

        ctx.fillStyle = getLedColor(brightness);
        ctx.fillRect(
          x * cellSize + padding,
          y * cellSize + padding,
          cellSize - padding * 2,
          cellSize - padding * 2,
        );
      }
    }
  };

  const handlePointerEvent = (e: PointerEvent) => {
    if (!canvasRef || props.disabled) return null;

    const rect = canvasRef.getBoundingClientRect();
    const scaleX = canvasRef.width / rect.width;
    const scaleY = canvasRef.height / rect.height;

    const x = Math.floor(
      ((e.clientX - rect.left) * scaleX) / (canvasRef.width / MATRIX_SIZE),
    );
    const y = Math.floor(
      ((e.clientY - rect.top) * scaleY) / (canvasRef.height / MATRIX_SIZE),
    );

    if (x >= 0 && x < MATRIX_SIZE && y >= 0 && y < MATRIX_SIZE) {
      const index = y * MATRIX_SIZE + x;
      const mappedIndex = props.indexData()[index];
      return { index, mappedIndex };
    }
    return null;
  };

  const handlePointerDown = (e: PointerEvent) => {
    if (props.disabled) return;
    e.preventDefault();

    const position = handlePointerEvent(e);
    if (!position) return;

    isDrawing = true;
    currentDrawValue = props.data()[position.mappedIndex] > 0 ? 0 : 255;
    props.onSetLed?.({ index: position.mappedIndex, status: currentDrawValue });

    const newState = props
      .data()
      .map((led, i) =>
        i === position.mappedIndex ? Number(currentDrawValue) : led,
      );

    props.onSetMatrix?.(newState);
  };

  const handlePointerMove = (e: PointerEvent) => {
    if (!isDrawing || props.disabled) return;
    e.preventDefault();

    const position = handlePointerEvent(e);
    if (!position) return;

    if (props.data()[position.mappedIndex] !== currentDrawValue) {
      props.onSetLed?.({
        index: position.mappedIndex,
        status: currentDrawValue,
      });

      const newState = props
        .data()
        .map((led, i) =>
          i === position.mappedIndex ? Number(currentDrawValue) : led,
        );

      props.onSetMatrix?.(newState);
    }
  };

  const handlePointerUp = () => {
    if (isDrawing && props.onSetMatrix) {
      props.onSetMatrix(props.data());
    }
    isDrawing = false;
  };

  onMount(() => {
    if (!canvasRef) return;

    canvasRef.width = 400;
    canvasRef.height = 400;

    drawMatrix(props.data(), props.indexData());

    canvasRef.addEventListener("pointerdown", handlePointerDown);
    canvasRef.addEventListener("pointermove", handlePointerMove);
    canvasRef.addEventListener("pointerup", handlePointerUp);
    canvasRef.addEventListener("pointerleave", handlePointerUp);
  });

  onCleanup(() => {
    if (!canvasRef) return;

    canvasRef.removeEventListener("pointerdown", handlePointerDown);
    canvasRef.removeEventListener("pointermove", handlePointerMove);
    canvasRef.removeEventListener("pointerup", handlePointerUp);
    canvasRef.removeEventListener("pointerleave", handlePointerUp);
  });

  createEffect(() => {
    const data = props.data();
    const indexData = props.indexData();

    if (canvasRef && data.length && indexData.length) {
      drawMatrix(data, indexData);
    }
  });

  return (
    <div
      ref={containerRef}
      class={`
        p-4 bg-[#111111]
        shadow-lg
        relative mx-auto flex-none inline-block
        transition-opacity duration-300
        ${visible() ? "opacity-100" : "opacity-50"}
        ${props.disabled ? "opacity-30" : ""}
        w-full h-[calc(100vh*0.8)] aspect-[3/4]
      `}
    >
      <canvas
        ref={canvasRef}
        class="w-full h-full self-center"
        style={{
          "image-rendering": "pixelated",
        }}
      />
    </div>
  );
};

export default LedMatrix;

================
File: frontend/src/components/screen-info.tsx
================
import { Component, ParentProps } from 'solid-js';

export const ScreenInfo: Component<ParentProps> = (props) => (
  <div class="grid p-8 h-full justify-center items-center">
    <div class="text-center text-white h-full flex justify-center items-center">
      <div>{props.children}</div>
    </div>
  </div>
);

================
File: frontend/src/components/sidebar.tsx
================
import { Component, For, Show, JSX } from "solid-js";
import { Store } from "../types";
import { Tooltip } from "./tooltip";

interface SidebarSectionProps {
  title: string;
  children: JSX.Element;
}

const SidebarSection: Component<SidebarSectionProps> = (props) => (
  <div class="space-y-3">
    <h3 class="text-sm font-semibold text-gray-700 uppercase tracking-wide">
      {props.title}
    </h3>
    <div class="space-y-2">{props.children}</div>
  </div>
);

interface SidebarProps {
  store: Store;
  onRotate: (turnRight: boolean) => void;
  onLoadImage: () => void;
  onClear: () => void;
  onPersist: () => void;
  onLoad: () => void;
  onPluginChange: (pluginId: number) => void;
  onBrightnessChange: (value: number) => void;
  onPersistPlugin: () => void;
}

export const Sidebar: Component<SidebarProps> = (props) => {
  return (
    <aside class="bg-white p-6 flex flex-col h-full">
      <SidebarSection title="Display Mode">
        <div class="flex flex-col gap-2.5">
          <select
            class="flex-1 px-2.5 py-2.5 bg-gray-50 border border-gray-200 rounded"
            onChange={(e) =>
              props.onPluginChange(parseInt(e.currentTarget.value))
            }
            value={props.store.plugin()}
          >
            <For each={props.store.plugins()}>
              {(plugin) => <option value={plugin.id}>{plugin.name}</option>}
            </For>
          </select>
          <Tooltip text="Save current display mode as default startup mode">
            <button
              onClick={props.onPersistPlugin}
              class="w-full bg-blue-600 text-white border-0 px-4 py-3 uppercase text-sm leading-6 tracking-wider cursor-pointer font-bold hover:opacity-80 active:translate-y-[-1px] transition-all rounded"
            >
              Set Default
            </button>
          </Tooltip>
        </div>
      </SidebarSection>

      <div class="my-6 border-t border-gray-200" />

      <SidebarSection title={`Rotation (${[0, 90, 180, 270][props.store.rotation()]}°)`}>
        <div class="flex gap-2.5">
          <Tooltip text="Rotate display counter-clockwise">
            <button
              onClick={() => props.onRotate(false)}
              class="w-full bg-blue-600 text-white border-0 px-4 py-3 uppercase text-sm leading-6 tracking-wider cursor-pointer font-bold hover:opacity-80 active:translate-y-[-1px] transition-all rounded"
            >
              <i class="fa-solid fa-rotate-left" />
            </button>
          </Tooltip>
          <Tooltip text="Rotate display clockwise">
            <button
              onClick={() => props.onRotate(true)}
              class="w-full bg-blue-600 text-white border-0 px-4 py-3 uppercase text-sm leading-6 tracking-wider cursor-pointer font-bold hover:opacity-80 active:translate-y-[-1px] transition-all rounded"
            >
              <i class="fa-solid fa-rotate-right" />
            </button>
          </Tooltip>
        </div>
      </SidebarSection>

      <div class="my-6 border-t border-gray-200" />

      <SidebarSection title="Brightness">
        <div class="space-y-2">
          <input
            type="range"
            min="0"
            max="255"
            value={props.store.brightness()}
            class="w-full"
            onInput={(e) =>
              props.onBrightnessChange(parseInt(e.currentTarget.value))
            }
          />
          <div class="text-sm text-gray-600 text-right">
            {Math.round((props.store.brightness() / 255) * 100)}%
          </div>
        </div>
      </SidebarSection>

      <Show when={props.store.plugin() === 1}>
        <div class="my-6 border-t border-gray-200" />

        <SidebarSection title="Matrix Controls">
          <div class="grid grid-cols-2 gap-2">
            <Tooltip text="Import image from your device">
              <button
                onClick={props.onLoadImage}
                class="w-full bg-blue-600 text-white border-0 px-4 py-3 uppercase text-sm leading-6 tracking-wider cursor-pointer font-bold hover:opacity-80 active:translate-y-[-1px] transition-all rounded"
              >
                <i class="fa-solid fa-file-import" />
              </button>
            </Tooltip>
            <Tooltip text="Clear all pixels">
              <button
                onClick={props.onClear}
                class="w-full bg-blue-600 text-white border-0 px-4 py-3 uppercase text-sm leading-6 tracking-wider cursor-pointer font-bold hover:opacity-80 active:translate-y-[-1px] transition-all rounded hover:bg-red-600"
              >
                <i class="fa-solid fa-trash" />
              </button>
            </Tooltip>
            <Tooltip text="Save current display state">
              <button
                onClick={props.onPersist}
                class="w-full bg-blue-600 text-white border-0 px-4 py-3 uppercase text-sm leading-6 tracking-wider cursor-pointer font-bold hover:opacity-80 active:translate-y-[-1px] transition-all rounded"
              >
                <i class="fa-solid fa-floppy-disk" />
              </button>
            </Tooltip>
            <Tooltip text="Load last saved state">
              <button
                onClick={props.onLoad}
                class="w-full bg-blue-600 text-white border-0 px-4 py-3 uppercase text-sm leading-6 tracking-wider cursor-pointer font-bold hover:opacity-80 active:translate-y-[-1px] transition-all rounded"
              >
                <i class="fa-solid fa-refresh" />
              </button>
            </Tooltip>
          </div>
        </SidebarSection>
      </Show>

      <div class="mt-auto pt-6 border-t border-gray-200">
        <Tooltip text="Create and edit animations">
          <a
            href="#/creator"
            class="inline-flex items-center text-gray-700 hover:text-gray-900 font-medium"
          >
            <i class="fa-solid fa-pencil mr-2" />
            Animation Creator
          </a>
        </Tooltip>
      </div>
    </aside>
  );
};

export default Sidebar;

================
File: frontend/src/components/tooltip.tsx
================
import { Component, JSX } from "solid-js";

interface TooltipProps {
  text: string;
  children: JSX.Element;
}

export const Tooltip: Component<TooltipProps> = (props) => (
  <div class="group relative inline-block w-full">
    {props.children}
    <div class="absolute w-max min-w-max pointer-events-none z-50 left-0 -top-8 bg-gray-900 text-white text-sm px-2 py-1 rounded opacity-0 group-hover:opacity-100 transition-opacity">
      {props.text}
      <div class="border-gray-900 border-solid border-t-[6px] border-x-[6px] border-x-transparent absolute -bottom-1.5 left-4" />
    </div>
  </div>
);

================
File: frontend/src/app.tsx
================
import { Component, createMemo, ParentProps, Show } from "solid-js";
import { Layout } from "./components/layout";
import { LedMatrix } from "./components/led-matrix";
import { loadImageAndGetDataArray, rotateArray } from "./helpers";
import { useStore } from "./store";
import { ScreenInfo } from "./components/screen-info";

export const App: Component = () => {
  const store = useStore();

  const rotatedMatrix = createMemo(() =>
    rotateArray(store!.indexMatrix(), store!.rotation()),
  );

  const wsMessage = (
    event:
      | "persist"
      | "load"
      | "clear"
      | "plugin"
      | "screen"
      | "led"
      | "persist-plugin"
      | "brightness",
    data?: any,
  ) =>
    store?.send(
      JSON.stringify({
        event,
        ...data,
      }),
    );

  const handleRotate = (turnRight = false) => {
    let currentRotation = store?.rotation() || 0;
    currentRotation = turnRight
      ? currentRotation > 3
        ? 1
        : currentRotation + 1
      : currentRotation <= 0
        ? 3
        : currentRotation - 1;

    store?.setRotation(currentRotation);
    store?.send(
      JSON.stringify({
        event: "rotate",
        direction: turnRight ? "right" : "left",
      }),
    );
  };

  const handleLoadImage = () => {
    loadImageAndGetDataArray((data) => {
      store?.setLeds(() =>
        store?.indexMatrix().map((index) => (data[index] ? 255 : 0)),
      );
      wsMessage("screen", { data });
    });
  };

  const handleClear = () => {
    store?.setLeds([...new Array(256).fill(0)]);
    wsMessage("clear");
    store?.toast(`Canvas cleared`, 1000);
  };

  const handlePersist = () => {
    wsMessage("persist");
    store?.toast(`Saved current state`, 1500);
  };

  const handleLoad = () => {
    wsMessage("load");
    store?.toast(`Saved state loaded`, 1500);
  };

  const handlePluginChange = (pluginId: number) => {
    wsMessage("plugin", { plugin: pluginId });
    store?.toast("Mode changed", 1000);
  };

  const handleBrightnessChange = (value: number) => {
    store?.setBrightness(value);
    wsMessage("brightness", { brightness: value });
  };

  const handlePersistPlugin = () => {
    wsMessage("persist-plugin");
    store?.toast(`Current mode set as default`, 1500);
  };

  const renderLedMatrix = () => (
    <div class="grid p-8 h-full justify-center items-center sm:p-4 sm:m-0">
      <Show
        when={store?.plugin() === 1}
        fallback={
          <ScreenInfo>
            <h2 class="text-4xl">A Plugin currently running</h2>
            <p class="text-xl mt-2 text-gray-300">
              Select "Draw" to show the canvas.
            </p>
          </ScreenInfo>
        }
      >
        <div
          style={{
            opacity: (store?.brightness() || 255) / 255,
          }}
        >
          <LedMatrix
            disabled={store?.plugin() !== 1}
            data={store?.leds || (() => [])}
            indexData={rotatedMatrix}
            onSetLed={(data) => {
              wsMessage("led", data);
            }}
            onSetMatrix={(data) => {
              store?.setLeds([...data]);
            }}
          />
        </div>
      </Show>
    </div>
  );

  return (
    <Show
      when={store?.connectionState() === 1}
      fallback={
        <Layout
          content={
            <ScreenInfo>
              <h2 class="text-4xl">{store?.connectionStatus}...</h2>
            </ScreenInfo>
          }
          sidebarContent={
            <div class="bg-white p-6">
              <a href="#/creator" class="text-gray-700 hover:text-gray-900">
                Creator
              </a>
            </div>
          }
        />
      }
    >
      <Layout
        content={renderLedMatrix()}
        store={store}
        onRotate={handleRotate}
        onLoadImage={handleLoadImage}
        onClear={handleClear}
        onPersist={handlePersist}
        onLoad={handleLoad}
        onPluginChange={handlePluginChange}
        onBrightnessChange={handleBrightnessChange}
        onPersistPlugin={handlePersistPlugin}
      />
    </Show>
  );
};

================
File: frontend/src/creator.tsx
================
import { Component, createEffect, createSignal, For, Show } from 'solid-js';
import { Button } from './components/button';
import CreatorSidebar from './components/creator-sidebar';
import { Layout } from './components/layout';
import { LedMatrix } from './components/led-matrix';
import { Tooltip } from './components/tooltip';
import { chunkArray, matrixToHexArray } from './helpers';
import { useStore } from './store';
import { ScreenInfo } from './components/screen-info';

export const Creator: Component = () => {
  const store = useStore();
  const [isPlaying, setIsPlaying] = createSignal(false);
  const [screenSignals, setScreenSignals] = createSignal<
    ReturnType<typeof createSignal<number[]>>[]
  >([]);
  const [currentFrame, setCurrentFrame] = createSignal<number[]>([]);
  const [intervalId, setIntervalId] = createSignal(0);

  let ref: HTMLDivElement;

  const createNewScreen = (initialData?: number[]) => {
    const [screen, setScreen] = createSignal(
      initialData || new Array(256).fill(0)
    );
    return [screen, setScreen] as const;
  };

  const scrollToEnd = () => {
    if (ref) {
      setTimeout(() => {
        ref?.scrollTo({
          top: 0,
          left: ref?.scrollWidth,
          behavior: 'smooth',
        });
      }, 20);
    }
  };

  const handleAddScreen = () => {
    setScreenSignals((signals) => {
      const lastScreen =
        signals.length > 0 ? signals[signals.length - 1][0]() : undefined;
      const newSignal = createNewScreen(
        lastScreen ? [...lastScreen] : undefined
      );
      scrollToEnd();
      return [...signals, newSignal];
    });
  };

  const handleRemoveScreen = (index: number) => {
    setScreenSignals((signals) => signals.filter((_, i) => i !== index));
  };

  const handleEmptyMatrix = (index: number) => {
    setScreenSignals((signals) => {
      if (index !== -1) {
        const [_, setScreen] = signals[index];
        setScreen(new Array(256).fill(0));
      }
      return signals;
    });
  };

  const handleUploadData = () => {
    const screens = screenSignals().map(([screen]) => screen());

    store!.send(
      JSON.stringify({
        event: 'upload',
        screens: screens.length,
        data: screens.map((screen) =>
          matrixToHexArray(screen.map((s) => (s > 0 ? 1 : 0)))
        ),
      })
    );

    const id = store?.plugins().find((p) => p.name.includes('Animation'))?.id;
    if (id) {
      store!.send(
        JSON.stringify({
          event: 'plugin',
          plugin: id,
        })
      );
    }
  };

  const handleExportData = () => {
    const animation = [];
    const screens = screenSignals().map(([screen]) => screen());
    for (const screen of screens) {
      animation.push(
        chunkArray(screen, 8).map(
          (chunk) =>
            `0x${parseInt(chunk.join(''), 2).toString(16).padStart(2, '0')}`
        )
      );
    }

    const element = document.createElement('a');
    element.setAttribute(
      'href',
      'data:text/plain;charset=utf-8,' +
        encodeURIComponent(
          `std::vector<std::vector<int>> frames = ${JSON.stringify(animation)
            .replace(/"/g, '')
            .replace(/]/g, '}')
            .replace(/\[/g, '{')};

int size = frames.size();
int count = 0;
if (size > 0)
{
    std::vector<int> bits = Screen.readBytes(frames[count]);
    for (int i = 0; i < bits.size(); i++)
    {
        Screen.setPixelAtIndex(i, bits[i]);
    }
    Screen.render();
    count++;
    if (count >= size)
    {
        count = 0;
    }
    delay(400);
}`
        )
    );
    element.setAttribute('download', 'animation.cpp');
    element.style.display = 'none';
    document.body.appendChild(element);
    element.click();
    element.remove();
  };

  const handleTogglePlay = () => {
    setIsPlaying(!isPlaying());
  };

  createEffect(() => {
    if (!isPlaying()) {
      clearInterval(intervalId());
      setIntervalId(0);
      scrollToEnd();
      return;
    }

    let i = 0;
    const run = () => {
      const screen = screenSignals()[i][0]();
      setCurrentFrame([...screen]);
      i++;
      if (i >= screenSignals().length) {
        i = 0;
      }
    };
    run();
    const newIntervalId: any = setInterval(run, 400);
    setIntervalId(newIntervalId);

    return () => {
      clearInterval(newIntervalId);
      setIntervalId(0);
      scrollToEnd();
    };
  });

  const renderFrames = () => (
    <div
      ref={ref!}
      class="snap-x snap-mandatory flex flex-nowrap overflow-x-auto gap-[15vw] h-full w-[calc(100vw-320px)] items-center px-[calc(50vw-320px)]"
    >
      <Show
        when={!isPlaying()}
        fallback={
          <div class="animate-fade-in">
            <LedMatrix data={currentFrame} indexData={store!.indexMatrix} />
          </div>
        }
      >
        <For each={screenSignals()}>
          {([screen, setScreen], index) => (
            <div class="snap-center">
              <header class="flex justify-between items-center mb-4">
                <div class="flex gap-2">
                  <Tooltip text="Remove current frame">
                    <Button
                      widthAuto
                      onClick={() => handleRemoveScreen(index())}
                      class="hover:bg-red-600 transition-colors w-auto"
                    >
                      <i class="fa-solid fa-trash" />
                    </Button>
                  </Tooltip>

                  <Tooltip text="Empty current frame">
                    <Button
                      onClick={() => handleEmptyMatrix(index())}
                      class="hover:bg-red-600 transition-colors"
                    >
                      <i class="fa-solid fa-eraser" />
                    </Button>
                  </Tooltip>
                </div>
                <div class="text-center text-2xl text-white flex items-center">
                  <span class="font-bold">{index() + 1}</span>
                  <span class="opacity-50">/{screenSignals().length}</span>
                </div>
              </header>
              <LedMatrix
                data={screen}
                indexData={store!.indexMatrix}
                onSetLed={(data) => {
                  const currentScreen = [...screen()];
                  currentScreen[data.index] = Number(data.status);
                  setScreen(currentScreen);
                }}
                onSetMatrix={(data) => {
                  setScreen([...data]);
                }}
              />
            </div>
          )}
        </For>
      </Show>
    </div>
  );

  return (
    <Show
      when={store!.connectionState() === 1}
      fallback={
        <Layout
          content={
            <ScreenInfo>
              <h2 class="text-4xl">{store?.connectionStatus}...</h2>
            </ScreenInfo>
          }
          sidebarContent={
            <div class="bg-white p-6">
              <a href="#/" class="text-gray-700 hover:text-gray-900">
                Back
              </a>
            </div>
          }
        />
      }
    >
      <Layout
        store={store}
        content={
          <div class="h-full relative">
            {screenSignals().length ? (
              renderFrames()
            ) : (
              <ScreenInfo>
                <h2 class="text-4xl">Create something awesome! 🙌.</h2>
              </ScreenInfo>
            )}
          </div>
        }
        sidebarContent={
          <CreatorSidebar
            hasScreens={screenSignals().length > 0}
            isPlaying={isPlaying()}
            onAddScreen={handleAddScreen}
            onExportData={handleExportData}
            onUploadData={handleUploadData}
            onTogglePlay={handleTogglePlay}
          />
        }
      />
    </Show>
  );
};

export default Creator;

================
File: frontend/src/helpers.ts
================
export const loadImageAndGetDataArray = (cb: (data: number[]) => void) => {
  const matrixSize = 16;
  const tempFileInput = document.createElement('input');
  tempFileInput.type = 'file';
  tempFileInput.click();

  tempFileInput.onchange = (e: Event) => {
    if (!e.target) return;
    const file = (e.target as HTMLInputElement).files?.[0]!;
    const reader = new FileReader();
    reader.readAsDataURL(file);
    reader.onload = () => {
      const image = new Image(matrixSize, matrixSize);
      image.src = reader.result as string;
      image.onload = () => {
        const canvas = new OffscreenCanvas(matrixSize, matrixSize);
        const ctx = canvas.getContext('2d');

        ctx?.drawImage(image, 0, 0, matrixSize, matrixSize);
        const imgData = ctx?.getImageData(0, 0, matrixSize, matrixSize);
        if (imgData) {
          const data: number[] = [];
          for (var i = 0; i < imgData.data.length; i += 4) {
            const isActive =
              imgData.data[i] + imgData.data[i + 1] + imgData.data[i + 2] <= 383
                ? 1
                : 0;
            data.push(isActive);
          }

          cb(data);
        }
      };
    };
  };
};

export const rotateArray = (matrix: number[], rotations: number) => {
  const SIZE = 16;
  const newState = [...matrix];

  const swap = (arr: number[], i: number, j: number) => {
    const temp = arr[i];
    arr[i] = arr[j];
    arr[j] = temp;
  };

  for (let row = 0; row < SIZE / 2; row++) {
    for (let col = row; col < SIZE - row - 1; col++) {
      for (let r = 0; r < rotations; r++) {
        swap(newState, row * SIZE + col, col * SIZE + (SIZE - 1 - row));
        swap(
          newState,
          row * SIZE + col,
          (SIZE - 1 - row) * SIZE + (SIZE - 1 - col)
        );
        swap(newState, row * SIZE + col, (SIZE - 1 - col) * SIZE + row);
      }
    }
  }

  return newState;
};

export const chunkArray = (input: number[], size: number) =>
  input.reduce((resultArray: number[][], item, index) => {
    const cIndex = Math.floor(index / size);

    if (!resultArray[cIndex]) {
      resultArray[cIndex] = [];
    }

    resultArray[cIndex].push(item);

    return resultArray;
  }, []);

export const matrixToHexArray = (matrix: number[]) =>
  chunkArray(matrix, 8).map((chunk) =>
    parseInt(parseInt(chunk.join(''), 2).toString(), 10)
  );

================
File: frontend/src/index.css
================
@tailwind base;
@tailwind components;
@tailwind utilities;

@layer base {
  :root {
    --multiplier: 1.5;
  }

  * {
    box-sizing: border-box;
  }

  html,
  body,
  #app {
    @apply h-full w-full m-0 p-0;
  }

  body {
    @apply font-sans text-base font-normal bg-[#9b8d82];
    font-synthesis: none;
    text-rendering: optimizeLegibility;
  }

  select {
    @apply px-2.5 py-2.5 text-base;
  }
}

@keyframes toastSlideUp {
  0% {
    opacity: 0;
    transform: translateY(1rem);
  }
  100% {
    opacity: 1;
    transform: translateY(0);
  }
}

.animate-toast-slide-up {
  animation: toastSlideUp 0.2s ease-out forwards;
}

================
File: frontend/src/index.tsx
================
import { render } from "solid-js/web";
import { createSignal, Match, onCleanup, onMount, Switch } from "solid-js";
import "./index.css"; // This now contains Tailwind imports

import { App } from "./app";
import { Creator } from "./creator";
import { StoreProvider } from "./store";

const Router = () => {
  const [hash, setHash] = createSignal(window.location.hash);
  const location = () => hash().replace(/^#/, "") || "/";

  const onChange = () => setHash(window.location.hash);

  onMount(() => {
    window.addEventListener("hashchange", onChange, false);
  });

  onCleanup(() => {
    window.removeEventListener("hashchange", onChange, false);
  });

  return (
    <div class="h-full">
      <Switch fallback={<App />}>
        <Match when={location() === "/creator"}>
          <Creator />
        </Match>
      </Switch>
    </div>
  );
};

render(
  () => (
    <StoreProvider>
      <Router />
    </StoreProvider>
  ),
  document.getElementById("app") as HTMLElement,
);

================
File: frontend/src/store.tsx
================
import { createEventSignal } from "@solid-primitives/event-listener";
import {
  createReconnectingWS,
  createWSState,
} from "@solid-primitives/websocket";
import {
  ParentComponent,
  Show,
  batch,
  createContext,
  createEffect,
  createSignal,
  useContext,
} from "solid-js";
import { SYSTEM_STATUS, Store } from "./types";

const StoreContext = createContext<Store>();

const ws = createReconnectingWS(
  `${
    import.meta.env.PROD
      ? `ws://${window.location.host}/`
      : import.meta.env.VITE_WS_URL
  }ws`,
);

const Toast = (props: { text: string }) => (
  <div class="fixed left-4 bottom-4 px-4 py-3 bg-gray-800 text-white shadow-lg border border-gray-700 flex items-center space-x-2 z-50 animate-toast-slide-up rounded-md">
    <i class="fa-solid fa-info-circle text-blue-400 mr-2" />
    <span>{props.text}</span>
  </div>
);

export const StoreProvider: ParentComponent = (props) => {
  const [toastNotification, setToastNotification] = createSignal<{
    text: string;
    duration: number;
  } | null>(null);
  const [rotation, setRotation] = createSignal(0);
  const [plugins, setPlugins] = createSignal([]);
  const [plugin, setPlugin] = createSignal(1);
  const [brightness, setBrightness] = createSignal(0);
  const [indexMatrix, setIndexMatrix] = createSignal(
    [...new Array(256)].map((_, i) => i),
  );
  const [leds, setLeds] = createSignal([...new Array(256)].fill(0));
  const [systemStatus, setSystemStatus] = createSignal<SYSTEM_STATUS>(
    SYSTEM_STATUS.NONE,
  );

  const state = createWSState(ws);

  const connectionStatus = [
    "Connecting",
    "Connected",
    "Disconnecting",
    "Disconnected",
  ];

  const messageEvent = createEventSignal<{ message: MessageEvent }>(
    ws,
    "message",
  );

  createEffect(() => {
    const json = JSON.parse(messageEvent()?.data || "{}");

    switch (json.event) {
      case "info":
        batch(() => {
          setSystemStatus(Object.values(SYSTEM_STATUS)[json.status as number]);
          setRotation(json.rotation);
          setBrightness(json.brightness);

          if (!plugins().length) {
            setPlugins(json.plugins);
          }

          if (json.plugin) {
            setPlugin(json.plugin as number);
          }

          if (plugin() === 1) {
            setIndexMatrix([...new Array(256)].map((_, i) => i));
          }

          if (json.data) {
            setLeds(json.data);
          }
        });
        break;
    }
  });

  const toast = (text: string, duration: number) => {
    setToastNotification(null);

    setTimeout(() => {
      setToastNotification({
        text,
        duration,
      });

      setTimeout(() => setToastNotification(null), duration);
    }, 50);
  };

  return (
    <StoreContext.Provider
      value={{
        rotation,
        brightness,
        indexMatrix,
        leds,
        plugins,
        plugin,
        setRotation,
        setBrightness,
        setIndexMatrix,
        setLeds,
        setPlugin,
        systemStatus,
        setSystemStatus,
        send: ws.send,
        connectionState: state,
        connectionStatus: connectionStatus[state()],
        toast,
      }}
    >
      <Show when={!!toastNotification()}>
        <Toast text={toastNotification()!.text} />
      </Show>
      {props.children}
    </StoreContext.Provider>
  );
};

export const useStore = () => useContext(StoreContext);

================
File: frontend/src/types.ts
================
import { Setter } from 'solid-js';

export enum SYSTEM_STATUS {
  NONE = 'draw',
  WSBINARY = 'wsbinary',
  // SYSTEM
  UPDATE = 'update',
  LOADING = 'loading',
}

export interface Store {
  rotation: () => number;
  brightness: () => number;
  indexMatrix: () => number[];
  leds: () => number[];
  plugins: () => { id: number; name: string }[];
  plugin: () => number;
  systemStatus: () => SYSTEM_STATUS;

  setRotation: Setter<number>;
  setBrightness: Setter<number>;
  setIndexMatrix: Setter<number[]>;
  setLeds: Setter<number[]>;
  setPlugin: Setter<number>;
  setSystemStatus: Setter<SYSTEM_STATUS>;
  send: (message: string | ArrayBuffer) => void;
  connectionState: () => number;

  connectionStatus?: string;
  toast: (text: string, duration: number) => void;
}

================
File: frontend/.env
================
VITE_WS_URL=ws://192.168.178.50/

================
File: frontend/compress.mjs
================
import { gzip } from '@gfx/zopfli';
import fs from 'fs';
import path from 'path';
import { fileURLToPath } from 'url';

const __filename = fileURLToPath(import.meta.url);
const __dirname = path.dirname(__filename);

const chunkArray = (input, size) =>
  input.reduce((resultArray, item, index) => {
    const cIndex = Math.floor(index / size);

    if (!resultArray[cIndex]) {
      resultArray[cIndex] = [];
    }

    resultArray[cIndex].push(item);

    return resultArray;
  }, []);

const addLineBreaks = (buffer) => {
  const chunks = chunkArray(buffer, 30);
  return chunks.reduce((data, chunk, index) => {
    data += chunk.join(',');
    if (index + 1 !== chunks.length) {
      data += ',\n';
    }
    return data;
  }, '');
};

gzip(
  fs.readFileSync('./dist/index.html', {
    encoding: 'utf-8',
  }),
  { numiterations: 30 },
  (err, output) => {
    if (err) {
      return console.error(err);
    }

    const FILE = `#include "webgui.h"

#ifdef ENABLE_SERVER

#include <ESPAsyncWebServer.h>

const uint32_t GUI_HTML_SIZE = ${output.length};
const uint8_t GUI_HTML[] PROGMEM = {${addLineBreaks(output)}};

void startGui(AsyncWebServerRequest *request)
{
  AsyncWebServerResponse *response = request->beginResponse_P(200, "text/html", GUI_HTML, GUI_HTML_SIZE);
  response->addHeader("Content-Encoding", "gzip");
  request->send(response);
}

#endif
`;

    fs.writeFileSync(path.resolve(__dirname, '../src/webgui.cpp'), FILE);
  }
);

================
File: frontend/index.html
================
<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="utf-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <meta name="theme-color" content="#9b8d82" />
    <link
      rel="stylesheet"
      href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.2.1/css/all.min.css"
      integrity="sha512-MV7K8+y+gLIBoVD59lQIYicR65iaqukzvf/nwasF0nqhPay5w/9lJmVM2hMDcnK1OnMGCdVK+iQrJ7lzPJQd1w=="
      crossorigin="anonymous"
      referrerpolicy="no-referrer"
    />
    <title>OBEGRÄNSAD Control</title>
  </head>
  <body>
    <noscript>You need to enable JavaScript to run this app.</noscript>
    <div id="app"></div>

    <script src="/src/index.tsx" type="module"></script>
  </body>
</html>

================
File: frontend/package.json
================
{
  "name": "frontend",
  "version": "0.0.0",
  "scripts": {
    "start": "vite",
    "dev": "vite",
    "build": "vite build && node compress.mjs",
    "serve": "vite preview"
  },
  "license": "MIT",
  "devDependencies": {
    "@gfx/zopfli": "^1.0.15",
    "@types/node": "^22.10.5",
    "@types/offscreencanvas": "^2019.7.3",
    "autoprefixer": "^10.4.20",
    "postcss": "^8.4.49",
    "tailwindcss": "^3.4.17",
    "typescript": "^5.7.3",
    "vite": "^6.0.7",
    "vite-plugin-singlefile": "^2.1.0",
    "vite-plugin-solid": "^2.11.0"
  },
  "dependencies": {
    "@radix-ui/react-separator": "^1.1.1",
    "@radix-ui/react-slot": "^1.1.1",
    "@solid-primitives/event-listener": "^2.3.3",
    "@solid-primitives/intersection-observer": "^2.1.6",
    "@solid-primitives/timer": "^1.3.10",
    "@solid-primitives/websocket": "^1.2.2",
    "solid-js": "^1.9.4",
    "tailwind-merge": "^2.6.0",
    "tailwindcss-animate": "^1.0.7"
  },
  "packageManager": "pnpm@9.15.2+sha512.93e57b0126f0df74ce6bff29680394c0ba54ec47246b9cf321f0121d8d9bb03f750a705f24edc3c1180853afd7c2c3b94196d0a3d53d3e069d9e2793ef11f321"
}

================
File: frontend/postcss.config.js
================
module.exports = {
  plugins: {
    tailwindcss: {},
    autoprefixer: {},
  },
}

================
File: frontend/tailwind.config.js
================
const plugin = require('tailwindcss/plugin');

/** @type {import('tailwindcss').Config} */
module.exports = {
  darkMode: ['class'],
  content: ['./src/**/*.{js,jsx,ts,tsx}'],
  theme: {},
  plugins: [require('tailwindcss-animate')],
};

================
File: frontend/tsconfig.json
================
{
  "compilerOptions": {
    "strict": true,
    "target": "ESNext",
    "module": "ESNext",
    "moduleResolution": "node",
    "allowSyntheticDefaultImports": true,
    "esModuleInterop": true,
    "jsx": "preserve",
    "jsxImportSource": "solid-js",
    "types": ["vite/client", "offscreencanvas"],
    "noEmit": true,
    "isolatedModules": true,
    "resolveJsonModule": true
  }
}

================
File: frontend/vite.config.mts
================
import { defineConfig } from 'vite';
import solidPlugin from 'vite-plugin-solid';
import { viteSingleFile } from 'vite-plugin-singlefile';

export default defineConfig({
  plugins: [
    solidPlugin(),
    viteSingleFile()
  ],
  server: {
    port: 3000,
  },
  build: {
    target: 'esnext',
  },
});
